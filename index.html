<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>å­—å¹•è‡ªåŠ¨é…å¯¹æ’­æ”¾å™¨ï¼ˆMP3 + SRT/LRCï¼‰</title>

<!-- âœ… åœ¨æ ‡é¢˜é™„è¿‘æ·»åŠ  favicon ç¼©ç•¥å›¾ -->
<link rel="icon" href="thumbnail.png" type="image/png" />
<link rel="apple-touch-icon" href="thumbnail.png" />
<!-- æˆ–è€…ä½¿ç”¨ ICO æ ¼å¼ -->
<!-- <link rel="icon" href="favicon.ico" type="image/x-icon" /> -->

  
<style>
  :root{
    --bg:#0f1115; --panel:#1a1d24; --text:#d7dbe7; --muted:#8e97a8; --active:#fff;
  }
  *{box-sizing:border-box}
  body{
    margin:0; color:var(--text); background:#0f1115;
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans CJK SC","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;
    display:grid; grid-template-rows:auto 1fr; height:100dvh; padding-bottom:env(safe-area-inset-bottom);
  }
  header{
    position:sticky; top:0; z-index:2;
    padding:12px 16px; display:grid; gap:8px; grid-template-columns:1fr auto;
    align-items:center; background:var(--panel); border-bottom:1px solid #222734;
  }
  .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .btn{appearance:none; border:0; border-radius:10px; background:#2a3040; color:#fff; padding:10px 14px; cursor:pointer}
  .btn:hover{filter:brightness(1.06)}
  .btn:active{transform:translateY(1px)}
  .select{background:#2a3040; color:#dfe7ff; border:0; border-radius:10px; padding:10px 12px}
  .hint{color:var(--muted); font-size:12px; margin:0}
  .time{font-variant-numeric:tabular-nums; color:#aab2c2}
  .timebox{display:inline-flex; align-items:center; gap:6px; white-space:nowrap; min-width:140px}
  .timebox .sep::before{content:"/"; opacity:.6}

  /* --- ä¸»ä½“åŒºåŸŸ --- */
  main{
    display:grid; grid-template-columns:420px 1fr; height:100%; min-height:0;
  }
  /* âœ… çª„å±ï¼šä¸¤è¡Œå¸ƒå±€ï¼Œç¬¬äºŒè¡Œå æ»¡å‰©ä½™é«˜åº¦ï¼Œå»æ‰ä¸­é—´â€œç©ºç™½å¸¦â€ */
  @media (max-width:900px){
    main{
      grid-template-columns:1fr;
      grid-template-rows:auto 1fr; /* å…³é”®ï¼šä¸Šå—è‡ªé«˜ï¼Œä¸‹å—å¡«æ»¡ */
    }
  }

  .left{border-right:1px solid #222734; padding:12px 16px 8px; display:grid; gap:10px; align-content:start; min-width:0}
  .right{position:relative; overflow:hidden; min-width:0; min-height:0}
  .lyrics{
    position:absolute; inset:0; overflow:auto; scroll-behavior:smooth;
    padding:18px 14px calc(28px + env(safe-area-inset-bottom));
  }

  .progress{width:100%; height:6px; background:#222735; border-radius:999px; overflow:hidden}
  .bar{height:100%; width:0; background:#5c7cfa; transition:width .2s linear}
  .line{padding:10px 12px; margin:2px 0; border-radius:12px; cursor:pointer; transition:.12s; opacity:.9}
  .line:hover{background:#1f2432}
  .line.future{color:#8e97a8; opacity:.7}
  .line.past{color:#c2c8d8}
  .line.active{background:#2c3345; color:#fff; transform:scale(1.02); box-shadow:0 8px 22px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.04)}

  /* çª„å±é¢å¤–æ”¶ç´§ */
  @media (max-width:600px){
    header{grid-template-columns:1fr}
    .controls{gap:8px}
    .btn{padding:9px 12px}
    .lyrics{padding:14px 12px calc(26px + env(safe-area-inset-bottom))}
  }
</style>
</head>
<body>
<header>
  <div class="controls">
    <button class="btn" id="playPause">â–¶ï¸ / â¸</button>
    <span class="timebox">
      <span class="time" id="cur">00:00</span>
      <span class="sep"></span>
      <span class="time" id="dur">00:00</span>
    </span>
    <div style="flex:1"></div>

    <!-- ç”µè„‘ç«¯ï¼šé€‰æ–‡ä»¶å¤¹ï¼ˆè‹¥æ”¯æŒï¼‰ -->
    <label class="btn" id="pickFolderBtn" for="pickerFolder" style="display:none">é€‰æ‹©æ–‡ä»¶å¤¹</label>
    <input id="pickerFolder" type="file" webkitdirectory directory multiple
           accept="audio/*,.srt,.lrc,.txt,text/plain" style="display:none" />

    <!-- é€šç”¨ï¼šå¤šé€‰æ–‡ä»¶ï¼ˆiOS/Android/æ¡Œé¢éƒ½å¯ç”¨ï¼‰ -->
    <label class="btn" id="pickFilesBtn" for="pickerFiles">é€‰æ‹©æ–‡ä»¶</label>
    <input id="pickerFiles" type="file" multiple
           accept="audio/*,.srt,.lrc,.txt,text/plain" style="display:none" />

    <select id="pairSelect" class="select" style="display:none"></select>
  </div>
  <p class="hint" id="hintText">
    ç”µè„‘ç«¯å¯â€œé€‰æ‹©æ–‡ä»¶å¤¹â€æˆ–å¤šé€‰æ–‡ä»¶ï¼›iOS éœ€ä»â€œæ–‡ä»¶â€App é€‰æ‹©ï¼ˆApple Music åº“ä¸æ”¯æŒï¼‰ã€‚
  </p>
</header>

<main>
  <section class="left">
    <audio id="player" preload="metadata" controls style="width:100%"></audio>
    <div class="progress"><div class="bar" id="bar"></div></div>
    <p class="hint">ç‚¹å‡»ä»»æ„ä¸€è¡Œè·³è½¬ï¼›â†‘/â†“ é€‰æ‹©è¡Œï¼ŒEnter è·³è½¬æ’­æ”¾ã€‚</p>
  </section>
  <section class="right">
    <div id="lyrics" class="lyrics" aria-label="lyrics list"></div>
  </section>
</main>

<script>
/* ===== å¹³å°èƒ½åŠ›æ£€æµ‹ï¼šiOSã€æ˜¯å¦æ”¯æŒç›®å½•é€‰æ‹© ===== */
const ua = navigator.userAgent || "";
const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
const canPickDir = "webkitdirectory" in document.createElement("input") && !isIOS;

/* ===== å…ƒç´ å¼•ç”¨ ===== */
const $ = s => document.querySelector(s);
const player = $('#player'), bar = $('#bar');
const playBtn = $('#playPause'), curEl = $('#cur'), durEl = $('#dur');
const pairSelect = $('#pairSelect'), lyricsWrap = $('#lyrics');
const pickFolderBtn = $('#pickFolderBtn'), pickerFolder = $('#pickerFolder');
const pickFilesBtn = $('#pickFilesBtn'), pickerFiles = $('#pickerFiles');

/* ===== æ ¹æ®å¹³å°è°ƒæ•´ UI / accept ===== */
if (canPickDir) pickFolderBtn.style.display = 'inline-block';
if (isIOS) {
  // æ”¾å¼€ acceptï¼Œé¿å… iOS Safari çš„æ··åˆç±»å‹è¿‡æ»¤ bug
  pickerFiles.removeAttribute('accept');
  $('#hintText').textContent = 'iOSï¼šè¯·ä»â€œæ–‡ä»¶â€App é€‰æ‹©æœ¬åœ°/äº‘ç›˜ä¸­çš„ MP3 ä¸ SRT/LRCï¼ˆApple Music åº“ä¸æ”¯æŒï¼‰ã€‚';
}

/* ===== å·¥å…·å‡½æ•° ===== */
let cues = [], activeIdx = -1;
const fmt = s => { if(!isFinite(s)) s=0; const m=Math.floor(s/60), ss=Math.floor(s%60); return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`; };
const ext = f => f.name.split('.').pop().toLowerCase();
const stem = f => f.name.replace(/\.[^.]+$/,'').toLowerCase();
const isAudio = e => /^(mp3|m4a|aac|wav|flac|ogg|oga|opus)$/i.test(e);
const isLyric = e => /^(srt|lrc|txt)$/i.test(e);
const escapeHtml = s => s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));

/* ===================== æœ¬åœ°ç¼“å­˜ï¼ˆIndexedDB + localStorageï¼‰ ===================== */
const DB_NAME = 'mp3srt-cache';
const STORE = 'files';
const META_KEY = 'mp3srt:lastMeta'; // {name, audioName, audioType, lyricName, lyricType}

/* å¯é…ç½®ï¼šæœ€å¤§å…è®¸ç¼“å­˜çš„éŸ³é¢‘ä½“ç§¯ï¼ˆMBï¼‰â€”â€”è¶…è¿‡åˆ™è·³è¿‡éŸ³é¢‘ç¼“å­˜ï¼Œä»…ç¼“å­˜å­—å¹• */
const MAX_AUDIO_MB = 120;

/* æ’­æ”¾è¿›åº¦å­˜å‚¨ */
const POS_KEY = 'mp3srt:lastPosV1';
let currentAudioId = null;

/* Storage helpers */
function idbOpen(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => req.result.createObjectStore(STORE);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbPut(key, blob){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).put(blob, key);
    tx.oncomplete = ()=>resolve();
    tx.onerror = ()=>reject(tx.error);
  });
}
async function idbGet(key){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE, 'readonly');
    const r = tx.objectStore(STORE).get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}
async function idbDel(key){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE, 'readwrite');
    tx.objectStore(STORE).delete(key);
    tx.oncomplete = ()=>resolve();
    tx.onerror = ()=>reject(tx.error);
  });
}
async function persistStorageIfPossible(){
  if (navigator.storage && navigator.storage.persist) {
    try { await navigator.storage.persist(); } catch {}
  }
}
async function reportStorage(){
  if (!navigator.storage || !navigator.storage.estimate) return;
  try {
    const { usage = 0, quota = 0 } = await navigator.storage.estimate();
    const usedMB = (usage / (1024*1024)).toFixed(1);
    const quotaMB = quota ? (quota / (1024*1024)).toFixed(1) : 'æœªçŸ¥';
    console.log(`Storage usage: ${usedMB}MB / ${quotaMB}MB`);
    if (quota && usage / quota > 0.8) {
      await idbDel('audioBlob'); // æ¥è¿‘ä¸Šé™ï¼šæ¸…ç†éŸ³é¢‘å‰¯æœ¬
      console.warn('æ¥è¿‘å­˜å‚¨ä¸Šé™ï¼Œå·²è‡ªåŠ¨æ¸…é™¤éŸ³é¢‘å‰¯æœ¬ï¼Œä»…ä¿ç•™å­—å¹•ç¼“å­˜ã€‚');
    }
  } catch {}
}

/* ä¿å­˜â€œä¸Šä¸€ç»„â€æ–‡ä»¶ï¼ˆè¦†ç›–å¼ï¼‰ */
async function saveCacheFromGroup(group){
  try {
    await persistStorageIfPossible();
    const meta = { name: group.name };

    if (group.audio) {
      const audioSizeMB = (group.audio.size || 0) / (1024*1024);
      if (audioSizeMB <= MAX_AUDIO_MB) {
        await idbPut('audioBlob', group.audio);
        meta.audioName = group.audio.name;
        meta.audioType = group.audio.type || 'audio/mpeg';
      } else {
        // è¶…é™ï¼šä¸ç¼“å­˜éŸ³é¢‘
        await idbDel('audioBlob');
        meta.audioName = `[skipped>${MAX_AUDIO_MB}MB] ${group.audio.name}`;
      }
    } else {
      await idbDel('audioBlob');
    }

    if (group.lyric) {
      await idbPut('lyricBlob', group.lyric);
      meta.lyricName = group.lyric.name;
      meta.lyricType = group.lyric.type || 'text/plain';
    } else {
      await idbDel('lyricBlob');
    }

    localStorage.setItem(META_KEY, JSON.stringify(meta));
  } catch (e) {
    console.warn('ä¿å­˜ç¼“å­˜å¤±è´¥ï¼š', e);
  }
}

async function clearCache(all=true){
  try {
    await idbDel('audioBlob');
    await idbDel('lyricBlob');
    localStorage.removeItem(META_KEY);
    if (all) localStorage.removeItem(POS_KEY); // åŒæ­¥æ¸…æ‰è¿›åº¦
  } catch (e) {
    console.warn('æ¸…é™¤ç¼“å­˜å¤±è´¥ï¼š', e);
  }
}

/** é¡µé¢å¯åŠ¨æ—¶å°è¯•ä»ç¼“å­˜æ¢å¤ä¸Šä¸€ç»„ */
async function tryRestoreFromCache(){
  const metaRaw = localStorage.getItem(META_KEY);
  if (!metaRaw) return false;
  let meta;
  try { meta = JSON.parse(metaRaw); } catch { return false; }

  const audioBlob = await idbGet('audioBlob');
  const lyricBlob = await idbGet('lyricBlob');
  if (!audioBlob && !lyricBlob) return false;

  const group = {
    name: meta.name || 'last',
    audio: audioBlob ? new File([audioBlob], meta.audioName || 'audio.mp3', { type: meta.audioType || audioBlob.type || 'audio/mpeg' }) : null,
    lyric: lyricBlob ? new File([lyricBlob], meta.lyricName || 'subtitle.srt', { type: meta.lyricType || lyricBlob.type || 'text/plain' }) : null,
  };

  await loadPair(group, {fromCache:true});
  $('#hintText').textContent = 'å·²è‡ªåŠ¨æ¢å¤ä¸Šæ¬¡æ’­æ”¾çš„æ–‡ä»¶ï¼ˆæœ¬åœ°ç¼“å­˜ï¼‰ã€‚å¦‚éœ€æ›´æ¢ï¼Œè¯·ç‚¹å‡»â€œé€‰æ‹©æ–‡ä»¶â€ã€‚';
  return true;
}

/* ===== å­—å¹•è§£æ ===== */
function parseLRC(text){
  const lines = text.replace(/\r/g,'').split('\n'); const list=[];
  for(const raw of lines){
    const ts=[...raw.matchAll(/\[(\d{1,2}):(\d{1,2})(?:[.:](\d{1,3}))?\]/g)];
    if(!ts.length) continue;
    const lyric = raw.replace(/\[[^\]]+\]/g,'').trim(); if(!lyric) continue;
    for(const m of ts){ const mm=+m[1], ss=+m[2], ms=m[3]? +m[3].padEnd(3,'0'):0; list.push({start:mm*60+ss+ms/1000, text:lyric});}
  }
  return list.sort((a,b)=>a.start-b.start);
}
function parseSRT(text){
  const blocks = text.replace(/\r/g,'').split(/\n\s*\n/), list=[];
  const re=/(\d\d?):(\d\d):(\d\d),(\d{3})\s*-->\s*(\d\d?):(\d\d):(\d\d),(\d{3})/;
  for(const b of blocks){
    const lines=b.split('\n').filter(Boolean); if(lines.length<2) continue;
    const m=lines[1].match(re); const t=lines.slice(2).join(' ').replace(/<[^>]+>/g,'').trim(); if(!m||!t) continue;
    const start=(+m[1])*3600+(+m[2])*60+(+m[3])+(+m[4])/1000; list.push({start,text:t});
  }
  return list.sort((a,b)=>a.start-b.start);
}
function pickParser(name,text){ return /\.srt$/i.test(name)||/-->\s*\d{1,2}:\d{2}:\d{2}/.test(text) ? parseSRT(text) : parseLRC(text); }

/* ===== æ¸²æŸ“ä¸é«˜äº® ===== */
function render(cuesList){
  lyricsWrap.innerHTML='';
  cuesList.forEach((c,i)=>{
    const div=document.createElement('div');
    div.className='line future'; div.dataset.idx=i; div.dataset.start=c.start;
    div.innerHTML=`<span class="time">${fmt(c.start)}</span> &nbsp; ${escapeHtml(c.text)}`;
    div.onclick=()=>{ player.currentTime=c.start+0.02; player.play(); setActive(i,true); };
    lyricsWrap.appendChild(div);
  });
  activeIdx=-1; setActiveByTime(0,true);
}
function setActive(i,center=false){
  if(i===activeIdx) return; activeIdx=i;
  const lines=[...lyricsWrap.querySelectorAll('.line')];
  lines.forEach((el,k)=>{ el.classList.remove('past','future','active');
    if(k<i) el.classList.add('past'); else if(k>i) el.classList.add('future');
  });
  const cur = lines[i]; if(cur){ cur.classList.add('active');
    const margin=120, top=cur.offsetTop-lyricsWrap.clientHeight/2+cur.clientHeight/2;
    const need = cur.offsetTop < lyricsWrap.scrollTop + margin ||
                 cur.offsetTop+cur.clientHeight > lyricsWrap.scrollTop+lyricsWrap.clientHeight - margin;
    if(center || need) lyricsWrap.scrollTo({top,behavior:'smooth'});
  }
}
function setActiveByTime(t,center=false){
  if(!cues.length) return;
  let lo=0, hi=cues.length-1, ans=0;
  while(lo<=hi){ const m=(lo+hi)>>1; if(cues[m].start<=t+0.001){ans=m; lo=m+1;} else hi=m-1; }
  setActive(ans,center);
}

/* ===== æ’­æ”¾å™¨äº‹ä»¶ ===== */
playBtn.onclick=()=> player.paused ? player.play() : player.pause();
player.ontimeupdate=()=>{
  curEl.textContent=fmt(player.currentTime);
  if(isFinite(player.duration)) bar.style.width=(player.currentTime/player.duration*100).toFixed(2)+'%';
  setActiveByTime(player.currentTime);
};
player.onloadedmetadata=()=> durEl.textContent=fmt(player.duration);
document.addEventListener('keydown',e=>{
  if(!cues.length) return;
  if(e.key==='ArrowDown'){ setActive(Math.min(activeIdx+1,cues.length-1),true); e.preventDefault(); }
  else if(e.key==='ArrowUp'){ setActive(Math.max(activeIdx-1,0),true); e.preventDefault(); }
  else if(e.key==='Enter'){ const t=cues[Math.max(0,activeIdx)].start; player.currentTime=t+0.02; player.play(); }
});

/* ===== è¿›åº¦è®°å¿†ï¼šlocalStorageï¼ˆæŒ‰â€œæ–‡ä»¶å|å¤§å°â€åŒºåˆ†ï¼‰ ===== */
function getAudioId(file){
  if (!file) return null;
  const size = typeof file.size === 'number' ? file.size : 0;
  return `${file.name}|${size}`;
}
function savePlayPos(){
  if (!currentAudioId || !isFinite(player.duration)) return;
  try {
    const posObj = { id: currentAudioId, t: Math.max(0, Math.min(player.currentTime, player.duration || 0)), ts: Date.now() };
    localStorage.setItem(POS_KEY, JSON.stringify(posObj));
  } catch {}
}
function readPlayPos(id){
  try {
    const raw = localStorage.getItem(POS_KEY);
    if (!raw) return null;
    const obj = JSON.parse(raw);
    if (obj && obj.id === id && typeof obj.t === 'number') return obj.t;
  } catch {}
  return null;
}
function throttle(fn, wait=3000){
  let last = 0; let timer = null;
  return function(){
    const now = Date.now();
    const remain = wait - (now - last);
    if (remain <= 0){
      last = now; fn();
    } else if (!timer){
      timer = setTimeout(()=>{ timer = null; last = Date.now(); fn(); }, remain);
    }
  };
}
const savePlayPosThrottled = throttle(savePlayPos, 3000);
document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'hidden') savePlayPos(); });
window.addEventListener('pagehide', savePlayPos);

/* ===== é€‰æ‹©æ–‡ä»¶ / æ–‡ä»¶å¤¹å¹¶è‡ªåŠ¨é…å¯¹ ===== */
async function handleFiles(fileList){
  const files = Array.from(fileList||[]);
  if(!files.length) return;

  const groups = new Map();
  for(const f of files){
    const ex = ext(f), st = stem(f);
    if(!(isAudio(ex)||isLyric(ex))) continue;
    if(!groups.has(st)) groups.set(st,{audio:null, lyric:null, name:st});
    const g = groups.get(st);
    if(isAudio(ex) && !g.audio) g.audio=f;
    if(isLyric(ex)) { if(!g.lyric || /\.srt$/i.test(f.name)) g.lyric=f; }
  }
  const pairs = [...groups.values()].filter(g=>g.audio||g.lyric);
  if(!pairs.length){ alert('æœªæ‰¾åˆ°å¯ç”¨çš„ MP3 æˆ– å­—å¹•æ–‡ä»¶'); return; }

  pairSelect.innerHTML='';
  pairs.forEach((g,i)=>{
    const label = `${g.name}` +
      (g.audio? ` [ğŸµ ${g.audio.name}]` : '') +
      (g.lyric? ` [ğŸ“ ${g.lyric.name}]` : ' [æ— å­—å¹•]');
    const opt=document.createElement('option'); opt.value=String(i); opt.textContent=label; pairSelect.appendChild(opt);
  });
  pairSelect.style.display = pairs.length>1 ? 'inline-block':'none';

  await loadPair(pairs[0]); pairSelect.value='0';
  pairSelect.onchange = async ()=>{ const idx=+pairSelect.value; await loadPair(pairs[idx]); };
}

pickerFiles.onchange = (e)=> handleFiles(e.target.files);
pickerFolder.onchange = (e)=> handleFiles(e.target.files);

/** åŠ è½½ä¸€ç»„æ–‡ä»¶å¹¶æ¸²æŸ“ï¼›opts.fromCache ç”¨äºæç¤ºæ–‡æœ¬æ§åˆ¶ä¸è‡ªåŠ¨æ’­æ”¾ */
async function loadPair(group, opts={}){
  // è®¾ç½®éŸ³é¢‘æº
  if(group.audio){
    player.src = URL.createObjectURL(group.audio);
  } else {
    player.removeAttribute('src');
  }

  // è®¾ç½®å­—å¹•
  if(group.lyric){
    const text = await group.lyric.text();
    cues = pickParser(group.lyric.name, text);
    render(cues);
  }else{
    cues = []; lyricsWrap.innerHTML = '<div class="line">ï¼ˆæ— å­—å¹•ï¼‰</div>';
  }

  // å½“å‰éŸ³é¢‘ IDï¼ˆç”¨äºè¿›åº¦è®°å¿†ï¼‰
  currentAudioId = group.audio ? getAudioId(group.audio) : null;

  // å…ƒæ•°æ®å°±ç»ªåæ¢å¤è¿›åº¦
  const restore = async () => {
    if (!currentAudioId) {
      if (opts.fromCache){ try { await player.play(); } catch {} }
      return;
    }
    const t = readPlayPos(currentAudioId);
    if (typeof t === 'number' && isFinite(player.duration) && t < player.duration - 0.5){
      try { player.currentTime = t; } catch {}
      if (opts.fromCache){ try { await player.play(); } catch {} }
    } else if (opts.fromCache){
      try { await player.play(); } catch {}
    }
  };
  if (isFinite(player.duration) && player.duration > 0){
    await restore();
  } else {
    player.addEventListener('loadedmetadata', restore, { once: true });
  }

  // è¦†ç›–ä¿å­˜â€œä¸Šä¸€ç»„â€æœ¬åœ°å‰¯æœ¬
  try { await saveCacheFromGroup(group); } catch {}

  // ç»‘å®šèŠ‚æµå­˜å‚¨
  player.removeEventListener('timeupdate', savePlayPosThrottled);
  player.addEventListener('timeupdate', savePlayPosThrottled);
}

/* ===================== å¯åŠ¨ï¼šå°è¯•æ¢å¤ï¼Œç»‘å®šéšè—æ¸…ç†æ‰‹åŠ¿ ===================== */
(async () => {
  await reportStorage();
  const restored = await tryRestoreFromCache();
  if (!restored) {
    $('#hintText').textContent = 'æç¤ºï¼šé€‰æ‹©ä¸€æ¬¡ MP3 å’Œå­—å¹•åï¼Œå°†è‡ªåŠ¨ä¿å­˜ä¸ºâ€œä¸Šæ¬¡æ’­æ”¾â€ï¼Œå¹¶è®°ä½æ’­æ”¾è¿›åº¦ï¼›ä¸‹æ¬¡æ‰“å¼€ä¼šè‡ªåŠ¨æ¢å¤ã€‚';
  }

  // é•¿æŒ‰æˆ–åŒå‡»æ’­æ”¾é”®ï¼šæ¸…ç†ç¼“å­˜+è¿›åº¦
  let pressTimer = null;
  playBtn.addEventListener('touchstart', () => {
    pressTimer = setTimeout(async () => {
      if (confirm('æ¸…é™¤æœ¬åœ°ç¼“å­˜ä¸ç»­æ’­è¿›åº¦ï¼Ÿ')) {
        await clearCache(true);
        alert('å·²æ¸…é™¤ç¼“å­˜ä¸è¿›åº¦ã€‚');
      }
    }, 800);
  });
  playBtn.addEventListener('touchend', ()=> { if (pressTimer) clearTimeout(pressTimer); });
  playBtn.addEventListener('dblclick', async ()=> {
    if (confirm('æ¸…é™¤æœ¬åœ°ç¼“å­˜ä¸ç»­æ’­è¿›åº¦ï¼Ÿ')) {
      await clearCache(true);
      alert('å·²æ¸…é™¤ç¼“å­˜ä¸è¿›åº¦ã€‚');
    }
  });
})();
</script>
</body>
</html>
